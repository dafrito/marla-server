<!DOCTYPE html>
<html>
<head>
<style>
table
{
border-collapse: collapse;
}
table td, table th
{
border: 1px solid grey;
}
</style>
<title>Chunked transfer encoding - Rainback</title>
<link rel=stylesheet type=text/css href="style.css">
</head>
<body>
<main class=content>
<h1>Chunked transfer encoding - Rainback</h1>
<h2>struct parsegraph_ChunkedPageRequest</h2>
<table>
<tr><td>void(*handler)(struct parsegraph_ClientRequest*, struct parsegraph_ChunkedPageRequest*)<td>Handler that is used to fill the resp internal input ring.
<tr><td>void* handleData<td>Space for opaque handler data.
<tr><td>int handleStage<td>The internal generation stage.
<tr><td>int index<td>The internal index of the generated input.
<tr><td>parsegraph_Ring* resp<td>The internal buffer that will be written as chunks.
<tr><td>enum parsegraph_ChunkResponseStage stage<td>The stage of chunk writing.
</table>
<p>
Set this to parsegraph_CHUNK_RESPONSE_TRAILER in the handler when the output is complete.
<h2>enum parsegraph_ChunkResponseStage</h2>
<table>
<tr><th>Constant<th>Value<th>Description
<tr><td>parsegraph_CHUNK_RESPONSE_GENERATE<td>0<td>Invokes the handler to generate data.
<tr><td>parsegraph_CHUNK_RESPONSE_HEADER<td>1<td>The header is to be written.
<tr><td>parsegraph_CHUNK_RESPONSE_RESPOND<td>2<td>The data is being written.
<tr><td>parsegraph_CHUNK_RESPONSE_TRAILER<td>3<td>No more data to be written. Set by the generator.
<tr><td>parsegraph_CHUNK_RESPONSE_DONE<td>4<td>No more data or framing to be written.
</table>
<h2>const char* parsegraph_nameChunkResponseStage(enum parsegraph_ChunkResponseStage stage)</h2>
Returns a user-readable string representing the chunk response stage.
<h2>struct parsegraph_ChunkedPageRequest* parsegraph_ChunkedPageRequest_new(size_t inputBufSize, parsegraph_ClientRequest* req)</h2>
Creates and returns a new parsegraph_ChunkedPageRequest using the given input buffer size and client request.
<h2>int parsegraph_writeChunk(struct parsegraph_ChunkedPageRequest* cpr, parsegraph_Ring* output)</h2>
Writes a chunk from the parsegraph_ChunkedPageRequest's generated input ring to the given output ring.
<p>
Returns 0 and sets the stage to parsegraph_CHUNK_RESPONSE_TRAILER if no more data is to be written.
<h2>void parsegraph_measureChunk(size_t slotLen, int avail, size_t* prefix_len, size_t* availUsed)</h2>
Measures into the given prefix_len and availUsed, the size of a chunk that will best fit the
given slot.
<h2>void parsegraph_ChunkedPageRequest_free(struct parsegraph_ChunkedPageRequest* cpr)</h2>
Destroys the given parsegraph_ChunkedPageRequest.
<h2>int parsegraph_ChunkedPageRequest_process(struct parsegraph_ChunkedPageRequest* cpr)</h2>
Writes the given parsegraph_ChunkedPageRequest to the given parsegraph_ClientRequest.
<h2>void parsegraph_chunkedRequestHandler(struct parsegraph_ClientRequest* req, enum parsegraph_ClientEvent ev, void* data, int datalen)</h2>
A request handler, for use with a parsegraph_ClientRequest.
</main>
<nav class=toc>
<h3>Chunked transfer encoding - Rainback</h3>
<ul>
<li>struct <b>parsegraph_ChunkedPageRequest</b>
<li>const char* <b>parsegraph_nameChunkResponseStage</b>(enum parsegraph_ChunkResponseStage stage)
<li>struct parsegraph_ChunkedPageRequest* <b>parsegraph_ChunkedPageRequest_new</b>()
<li>int <b>parsegraph_writeChunk</b>(struct parsegraph_ChunkedPageRequest* cpr, parsegraph_Ring* output)
<li>void <b>parsegraph_measureChunk</b>(size_t slotLen, int avail, size_t* prefix_len, size_t* availUsed)
<li>void <b>parsegraph_ChunkedPageRequest_free</b>(struct parsegraph_ChunkedPageRequest* cpr)
<li>void <b>parsegraph_ChunkedPageRequest_process</b>(struct parsegraph_ChunkedPageRequest* cpr)
</ul>
</nav>
</body>
</html>
