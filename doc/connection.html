<!DOCTYPE html>
<html>
<head>
<style>
table
{
border-collapse: collapse;
}
table td, table th
{
border: 1px solid grey;
}
</style>
<title>Connection - Rainback</title>
<link rel=stylesheet type=text/css href="style.css">
</head>
<body>
<main class=content>
<h1>Connections - Rainback</h1>
<h2>struct parsegraph_Connection</h2>
<table>
<tr><th>Member<th>Description
<tr><th colspan=2>Flags</th>
<tr><td>int shouldDestroy<td>Indicates this connection be closed and destroyed immediately.
<tr><td>int wantsWrite<td>Indicates this connection will wait for a write.
<tr><td>int wantsRead<td>Indicates this connection will wait for a read.
<tr><td>enum parsegraph_ConnectionStage stage<td>Processing stage.
<tr><td>struct parsegraph_Server* server<td>The connection's associated server.
<tr><td>struct parsegraph_Connection* prev_connection<td>Server's previous connection.
<tr><td>struct parsegraph_Connection* next_connection<td>Server's next connection.
<tr><th colspan=2>Requests</th>
<tr><td>parsegraph_ClientRequest* current_request<td>This connection's first request.
<tr><td>parsegraph_ClientRequest* latest_request<td>This connection's last request.
<tr><td>size_t requests_in_process<td>The number of requests currently in queue.
<tr><th colspan=2>Buffers</th>
<tr><td>parsegraph_Ring* input<td>The connection's input buffer.
<tr><td>parsegraph_Ring* output<td>The connection's output buffer.
<tr><th colspan=2>Source</th>
<tr><td>void* source<td>Source's opaque data
<tr><td>int(*readSource)(struct parsegraph_Connection*, void*, size_t)<td>Function to read from source.
<tr><td>int(*writeSource)(struct parsegraph_Connection*, void*, size_t)<td>Function to write to source.
<tr><td>void(*acceptSource)(struct parsegraph_Connection*)<td>Function to accept a new connection. Must set the connection stage to ACCEPTED once done.
<tr><td>int(*shutdownSource)(struct parsegraph_Connection*)<td>Function to shutdown a connection before closing. Returns 0 if shutdown is complete, -1 otherwise.
<tr><td>void(*destroySource)(struct parsegraph_Connection*)<td>Function to destroy this connection's source.
<tr><td>int(*describeSource)(struct parsegraph_Connection*, char*, size_t)<td>Function to describe this connection's source to the user.
<tr><td>struct epoll_event poll<td>epoll event queue
</table>
<h2>enum parsegraph_ConnectionStage</h2>
<table>
<tr><th>Member<th>Description
<tr><td>parsegraph_CLIENT_ACCEPTED<td>struct has been created and socket FD has been set
<tr><td>parsegraph_CLIENT_SECURED<td>SSL has been accepted
<tr><td>parsegraph_BACKEND_READY<td>Backend ready for requests
<tr><td>parsegraph_CLIENT_COMPLETE<td>Done with connection
</table>
<h2>const char* parsegraph_nameConnectionStage(enum parsegraph_ConnectionStage)</h2>
Names the given connection stage.
<h2>parsegraph_Connection* parsegraph_Connection_new(struct parsegraph_Server* server)</h2>
Creates a new connection using the given parsegraph_Server.
<h2>void parsegraph_Connection_putback(parsegraph_Connection* cxn, size_t amount)</h2>
Puts back the number of bytes so that they are once again available to read.
<h2>void parsegraph_Connection_putbackWrite(parsegraph_Connection* cxn, size_t amount)</h2>
Reverses the connection's write head so that the given number of bytes are no longer written.
<h2>int parsegraph_Connection_read(parsegraph_Connection* cxn, char* sink, size_t requested)</h2>
Reads from the given connection's input, into the given area of user memory. The number of bytes actually read
is returned, 0 if there are no more bytes for this connection, and -1 if the underlying source is not ready for reading.
<h2>void parsegraph_Connection_handle(parsegraph_Connection* cxn)</h2>
Processes requests on the given connection.
<h2>void parsegraph_Connection_destroy(parsegraph_Connection* cxn)</h2>
Destroys the connection and all its requests.
<h2>int parsegraph_Connection_flush(parsegraph_Connection* cxn, int* outnflushed)</h2>
Flushes the connection's buffers to their sources. If outnflushed is nonzero, its value is set to the number of bytes
actually written to the source.
<h2>int parsegraph_Connection_write(parsegraph_Connection* cxn, const char* source, size_t requested)</h2>
Writes up to the requested number of bytes from source to the connection's output. The number of bytes actually written
is returned, or -1 if the underlying source is not ready for writing.
</main>
<nav class=toc>
<h3>Connections - Rainback</h3>
<ul>
<li>struct <b>parsegraph_Connection</b>
<li>enum <b>parsegraph_ConnectionStage</b>
<li>const char* <b>parsegraph_nameConnectionStage</b>(enum parsegraph_ConnectionStage)
<li>struct <b>parsegraph_Connection</b>
<li>parsegraph_Connection* <b>parsegraph_Connection_new</b>(struct parsegraph_Server* server)
<li>void <b>parsegraph_Connection_putback</b>(parsegraph_Connection* cxn, size_t amount)
<li>void <b>parsegraph_Connection_putbackWrite</b>(parsegraph_Connection* cxn, size_t amount)
<li>int <b>parsegraph_Connection_read</b>(parsegraph_Connection* cxn, char* sink, size_t requested)
<li>void <b>parsegraph_Connection_handle</b>(parsegraph_Connection* cxn)
<li>void <b>parsegraph_Connection_destroy</b>(parsegraph_Connection* cxn)
<li>int <b>parsegraph_Connection_flush</b>(parsegraph_Connection* cxn, int* outnflushed)
<li>int <b>parsegraph_Connection_write</b>(parsegraph_Connection* cxn, const char* source, size_t requested)
</ul>
</nav>
</body>
</html>
