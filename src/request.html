<!DOCTYPE html>
<html>
<head>
<style>
table
{
border-collapse: collapse;
}
table td, table th
{
border: 1px solid grey;
}

tr.backend td {
background: lightgrey;
}
</style>
<title>Request - Marla</title>
<link rel=stylesheet type=text/css href="style.css">
</head>
<body>
<main class=content>
<h1>Request - <a href="index.html">Marla</a></h1>
<h2>enum marla_RequestReadStage</h2>
Stages of reading a client request. Reads occur either from clients as original requests,
or from backends as returned responses.
<p>
<table>
<tr><th>Constant<th>Parsing position
<tr><td>marla_CLIENT_REQUEST_READ_FRESH<td>Before or at client's HTTP request line.
<tr class=backend><td>marla_BACKEND_REQUEST_FRESH<td>Before or at backend's response line.
<tr><td>marla_CLIENT_REQUEST_READING_METHOD<td>Client's HTTP method.
<tr><td>marla_CLIENT_REQUEST_PAST_METHOD<td>Client's whitespace after the HTTP method.
<tr><td>marla_CLIENT_REQUEST_READING_REQUEST_TARGET<td>Client's HTTP request target.
<tr><td>marla_CLIENT_REQUEST_PAST_REQUEST_TARGET<td>Client's whitespace after the HTTP request target.
<tr><td>marla_CLIENT_REQUEST_READING_VERSION<td>Client's HTTP version.
<tr class=backend><td>marla_BACKEND_REQUEST_READING_RESPONSE_LINE<td>Backend's HTTP response line.
<tr class=backend><td>marla_BACKEND_REQUEST_READING_HEADERS<td>Backend headers.
<tr><td>marla_CLIENT_REQUEST_READING_FIELD<td>Client's HTTP headers.
<tr><td>marla_CLIENT_REQUEST_AWAITING_CONTINUE_WRITE<td>After client's HTTP headers.
<tr><td>marla_CLIENT_REQUEST_AWAITING_UPGRADE_WRITE<td>After client's HTTP headers.
<tr><td>marla_CLIENT_REQUEST_READING_REQUEST_BODY<td>Client's HTTP request body.
<tr><td>marla_CLIENT_REQUEST_WEBSOCKET<td>Client's WebSocket connection.
<tr class=backend><td>marla_BACKEND_REQUEST_AWAITING_RESPONSE<td>After backend's HTTP response headers.
<tr class=backend><td>marla_BACKEND_REQUEST_READING_RESPONSE_BODY<td>Backend's HTTP response body.
<tr><td>marla_CLIENT_REQUEST_READING_CHUNK_SIZE<td>Client's HTTP request chunk header.
<tr><td>marla_CLIENT_REQUEST_READING_CHUNK_BODY<td>Client's HTTP request chunk body.
<tr class=backend><td>marla_BACKEND_REQUEST_READING_CHUNK_SIZE<td>Backend's HTTP response chunk header.
<tr class=backend><td>marla_BACKEND_REQUEST_READING_CHUNK_BODY<td>Backend's HTTP response chunk header.
<tr><td>marla_CLIENT_REQUEST_READING_TRAILER<td>Client's HTTP request trailers.
<tr class=backend><td>marla_BACKEND_REQUEST_READING_TRAILER<td>Backend's HTTP response trailers.
<tr><td>marla_CLIENT_REQUEST_DONE_READING<td>After client's request.
<tr class=backend><td>marla_BACKEND_REQUEST_DONE_READING<td>After backend's response.
</table>
<h2>enum marla_RequestWriteStage</h2>
<table>
<tr><th>Constant<th>Client write head position
<tr><td>marla_CLIENT_REQUEST_WRITE_AWAITING_ACCEPT<td>Nothing written
<tr class=backend><td>marla_BACKEND_REQUEST_WRITING_REQUEST_LINE<td>Backend's request line.
<tr class=backend><td>marla_BACKEND_REQUEST_WRITING_HEADERS<td>Backend request headers.
<tr class=backend><td>marla_BACKEND_REQUEST_WRITING_REQUEST_BODY<td>Backend request body.
<tr><td>marla_CLIENT_REQUEST_WRITING_UPGRADE<td>Writing server's Upgrade response
<tr><td>marla_CLIENT_REQUEST_WRITING_CONTINUE<td>Writing server's 100 continue response.
<tr><td>marla_CLIENT_REQUEST_WRITING_RESPONSE<td>Writing server's HTTP response body.
<tr><td>marla_CLIENT_REQUEST_WRITING_WEBSOCKET_RESPONSE<td>Writing server's WebSocket response.
<tr class=backend><td>marla_BACKEND_REQUEST_WRITING_TRAILERS<td>Backend request trailers.
<tr class=backend><td>marla_BACKEND_REQUEST_DONE_WRITING<td>After backend's HTTP request.
<tr><td>marla_CLIENT_REQUEST_DONE_WRITING<td>After server's HTTP response.
</table>
<h2>enum marla_ClientEvent</h2>
These tables are part of the same enumeration.
<p>
Core events:
</p>
<table>
<tr><th>Constant<th>Description<th>Meaning of data<th>Meaning of datalen
<tr><td>marla_EVENT_HEADER<td>HTTP header available to read. Name terminated by null.<td>HTTP header name and value.<td>Offset into HTTP header for reading header value.
<tr><td>marla_EVENT_ACCEPTING_REQUEST<td>Request headers read. Handler must accept request<td>Pointer to integer. If integer is set to nonzero, request is accepted.<td>None
<tr><td>marla_EVENT_REQUEST_BODY<td>HTTP request body ready.<td>Pointer to data buffer. This is set to zero if no more data is incoming.<td>Length of data. This is set to zero if no more data is incoming.
<tr><td>marla_EVENT_FORM_FIELD<td><td><td>
<tr><td>marla_EVENT_MUST_WRITE<td>Client request is expecting a response.Set request's writeStage to marla_CLIENT_REQUEST_DONE_WRITING when done writing.<td>Pointer to integer. Set to nonzero if choked<td>None
<tr><td>marla_EVENT_DESTROYING<td>The request is about to be freed<td>None<td>None
</table>
<p>
Websocket events:
</p>
<table>
<tr><td>marla_EVENT_WEBSOCKET_MUST_READ<td><td>Pointer to data buffer of WebSocket frame. This is set to zero when the frame has ended.<td>Length of data at buffer. This is set to zero when the frame has ended.
<tr><td>marla_EVENT_WEBSOCKET_MUST_WRITE<td>WebSocket is ready for writing<td>Pointer to integer. Set to -1 if the handler has choked, 0 if the handler can be invoked again. Default is -1.<td>None
<tr><td>marla_EVENT_WEBSOCKET_CLOSING<td>A WebSocket close frame was received<td><a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">2-byte character Close status code</a><td>The length of the status code. Defined as 2.
<tr><td>marla_EVENT_WEBSOCKET_CLOSE_REASON<td>The reason for the close is being received<td>Bytes received in the WebSocket close reason<td>Number of characters read
</table>
<p>
Backend events:
</p>
<table>
<tr><td>marla_EVENT_BACKEND_PEER_CLOSED<td>The backend request's connection was closed.<td>None<td>None
<tr><td>marla_BACKEND_EVENT_NEED_HEADERS<td>The backend request is ready for its request headers. Pointer to integer. Set to -1 if choked and set to 1 when headers are fully written (i.e. terminated by \r\n\r\n)<td>None<td>None
<tr><td>marla_BACKEND_EVENT_HEADER<td>Backend's HTTP header available to read. Name terminated by null.<td>HTTP header name and value.<td>Offset into HTTP header for reading header value.
<tr><td>marla_BACKEND_EVENT_MUST_READ<td>The backend request's response is ready for reading.<td>None<td>None
<tr><td>marla_BACKEND_EVENT_MUST_WRITE<td>The backend request's response is ready for writing.<td>None<td>None
<tr><td>marla_BACKEND_EVENT_NEED_TRAILERS<td>The backend request is now expecting trailer fields.<td>Pointer to integer. Set to nonzero when trailers are fully written (i.e terminated by \r\n\r\n)<td>None
<tr><td>marla_BACKEND_EVENT_CLIENT_PEER_CLOSED<td>The client request's connection was closed.<td>None<td>None
<tr><td>marla_BACKEND_EVENT_CLOSING<td>The backend request's connection is closing.<td>None<td>None
</table>
<h2>struct marla_Request</h2>
<table>
<tr><th>Member<th>Description
<tr><td>struct marla_Request* next_request<td>The next request in line for this connection.
<tr><td>int id<td>A server-unique identifier for this request.
<tr><td>int statusCode<td>HTTP status code
<tr><td>char statusLine[MAX_FIELD_VALUE_LENGTH + 1]<td>HTTP status line text
<tr><td>struct marla_Connection* cxn<td>Underlying client connection
<tr><td>char method[MAX_METHOD_LENGTH + 1]<td>HTTP method
<tr><td>char host[MAX_FIELD_VALUE_LENGTH + 1]<td>HTTP host
<tr><td>char uri[MAX_URI_LENGTH + 1]<td>HTTP request target
<tr><td>char error[marla_BUFSIZE]<td>Error message
<tr><td>char contentType[MAX_FIELD_VALUE_LENGTH + 1]<td>Content-Type header value
<tr><td>int is_backend<td>Indicates if the client request is for a backend connection
<tr><td>enum marla_RequestReadStage readStage<td>Request's read stage
<tr><td>enum marla_RequestWriteStage writeStage<td>Request's write stage
<tr><td>int expect_upgrade<td>Indicates this request expects an upgrade to a different protocol.
<tr><td>int expect_continue<td>Indicates this request expects a 100 Continue response to be written.
<tr><td>int expect_trailer<td>Indicates this request expects HTTP trailer fields.
<tr><td>int expect_websocket<td>Indicates this request expected an upgrade to WebSocket.
<tr><td>int close_after_done<td>Indicates the connection will close once this request is complete.
<tr><td>void(*handle)(struct marla_Request*, enum marla_ClientEvent, void*, int)<td>Handles request events.
<tr><td>void* handleData<td>Internal data used for request events.
<tr><td>struct marla_Request* backendPeer<td>The other request being processed on account of this one.
<tr><td>long int requestLen<td>The length in bytes of the request body. Set to the value given by the Content-Length header.
<tr><td>long int responseLen<td>The length in bytes of the response body.
<tr><td>long int remainingResponseLen<td>When writing fixed-length backend responses, this is the bytes remaining to be written.
<tr><td>long int totalContentLen<td>
<tr><td>long int chunkSize<td>
<tr><td>char redirectLocation[MAX_FIELD_VALUE_LENGTH + 1]<td>The Location: header value
<tr><td>char setCookieHeader[MAX_FIELD_VALUE_LENGTH + 1]<td>The Set-Cookie: header value
<tr><td>char cookieHeader[MAX_FIELD_VALUE_LENGTH + 1]<td>The Cookie: header value
<tr><td>char websocket_nonce[MAX_WEBSOCKET_NONCE_LENGTH + 1]<td>
<tr><td>char websocket_accept[2 * SHA_DIGEST_LENGTH + 1]<td>
<tr><td>unsigned char websocket_frame[7]<td>
<tr><td>int websocket_pingLen<td>
<tr><td>unsigned char websocket_ping[MAX_WEBSOCKET_CONTROL_PAYLOAD]<td>
<tr><td>char websocket_pongLen<td>
<tr><td>unsigned char websocket_pong[MAX_WEBSOCKET_CONTROL_PAYLOAD]<td>
<tr><td>unsigned char websocket_closeReason[MAX_WEBSOCKET_CONTROL_PAYLOAD]<td>
<tr><td>char websocket_closeReasonLen<td>
<tr><td>uint16_t websocket_closeCode<td>
<tr><td>int websocket_type<td>
<tr><td>int websocket_fin<td>
<tr><td>int needWebSocketClose<td>
<tr><td>int doingPong<td>
<tr><td>int doingWebSocketClose<td>
<tr><td>uint64_t websocketFrameWritten<td>
<tr><td>uint64_t websocketFrameOutLen<td>
<tr><td>uint64_t websocketFrameRead<td>
<tr><td>uint64_t websocketFrameLen<td>
<tr><td>char websocketOutMask[4]<td>
<tr><td>char websocketMask[4]<td>
<tr><td>int websocket_version<td>
</table>
<h2>marla_Request* marla_Request_new(marla_Connection* connection)</h2>
Creates a new marla_Request using the given connection. The request is not enqueued in the connection.
<h2>void marla_dumpRequest(marla_Request* req)</h2>
Dumps information on the given request to stderr.
<h2>void marla_Request_destroy(marla_Request* request)</h2>
Dispatches marla_EVENT_DESTROYING event on the given request's handler and then frees the request.
<h2>void marla_killRequest(marla_Request* request, const char* reason, ...)</h2>
Ends the connection immediately, recording the reason as a formatted string in <code>error</code>.
<h2>int marla_clientAccept(marla_Connection* cxn)</h2>
Accepts the given client connection.
<ul>
<li>Returns 0 if the connection has been accepted.
<li>Returns -1 if the connection has not been secured yet.
</ul>
<h2>int marla_clientRead(marla_Connection* cxn)</h2>
Consume HTTP requests and WebSocket input on the given connection.
<ul>
<li>Returns 0 if the function should be called again.
<li>Returns -1 if the function has choked and should not be called again.
<li>Returns 1 if the function needs to close the connection.
</ul>
<h2>int marla_clientWrite(marla_Connection* cxn)</h2>
Produce HTTP responses and WebSocket output on the given connection.
<ul>
<li>Returns 0 if the function should be called again.
<li>Returns -1 if the function has choked and should not be called again.
<li>Returns 1 if the function needs to close the connection.
</ul>
<h2>int marla_writeWebSocketHeader(struct marla_Request* req, unsigned char opcode, uint64_t frameLen)</h2>
Writes a frame header of the given parameters to the request's output.
<ul>
<li>%x0 denotes a continuation frame
<li>%x1 denotes a text frame
<li>%x2 denotes a binary frame
<li>%x3-7 are reserved for further non-control frames
<li>%x8 denotes a connection close
<li>%x9 denotes a ping
<li>%xA denotes a pong
<li>%xB-F are reserved for further control frames
</ul>
<h2>int marla_writeWebSocket(struct marla_Request* req, unsigned char* data, int dataLen)</h2>
Writes up to the given number of bytes into data. The number of bytes actually written is returned, or -1 if the underlying source is not ready for writing.
<h2>int marla_readWebSocket(struct marla_Request* req, unsigned char* data, int dataLen)</h2>
Reads up to the given number of bytes into data from the request's WebSocket frame.
The number of bytes actually read is returned, 0 if there are no more bytes for this connection, and -1 if the underlying source is not ready for reading.
<h2>int marla_WebSocketRemaining(struct marla_Request* req)</h2>
Returns the number of bytes remaining to be read in the given frame.
<h2>void marla_putbackWebSocketRead(struct marla_Request* req, int dataLen)</h2>
Puts back the given WebSocket frame bytes.
<h2>void marla_putbackWebSocketWrite(struct marla_Request* req, int dataLen)</h2>
Puts back the given WebSocket frame bytes.
<h2>const char* marla_nameRequestReadStage(enum marla_RequestReadStage stage)</h2>
Returns a user-readable string naming the given read stage.
<h2>const char* marla_nameRequestWriteStage(enum marla_RequestWriteStage stage)</h2>
Returns a user-readable string naming the given write stage.
<h2>const char* marla_nameClientEvent(enum marla_ClientEvent ev)</h2>
Names the given client event.
<h2>MIN_METHOD_LENGTH</h2>
The minimum tolerated length, in bytes, of a method.
<h2>MAX_METHOD_LENGTH</h2>
The maximum tolerated length, in bytes, of a method.
<h2>MAX_FIELD_NAME_LENGTH</h2>
The maximum tolerated length, in bytes, of a HTTP header name.
<h2>MAX_FIELD_VALUE_LENGTH</h2>
The maximum tolerated length, in bytes, of a HTTP header value.
<h2>MAX_WEBSOCKET_NONCE_LENGTH</h2>
The maximum length, in bytes, of a WebSocket nonce.
<h2>MAX_URI_LENGTH</h2>
The maxmimum length, in bytes, of a HTTP request target.
<h2>marla_MAX_CHUNK_SIZE</h2>
The maximum size of a single HTTP chunk body.
<h2>marla_MAX_CHUNK_SIZE_LINE</h2>
The maximum size of a single HTTP chunk header.
<h2>MAX_WEBSOCKET_CONTROL_PAYLOAD</h2>
The maximum size of a single HTTP chunk header.
<h2>marla_MESSAGE_IS_CHUNKED</h2>
Flag that indicates the HTTP response uses chunked transfer-coding.
<h2>marla_MESSAGE_LENGTH_UNKNOWN</h2>
Flag that indicates the HTTP response's length is not known.
<h2>marla_MESSAGE_USES_CLOSE</h2>
Flag that indicates the connection should be closed once the response is written.
</main>
<nav class=toc>
<h3>Request - <a href="index.html">Marla</a></h3>
<ul>
<li>enum <b>marla_RequestReadStage</b>
<li>enum <b>marla_RequestWriteStage</b>
<li>enum <b>marla_ClientEvent</b>
<li>struct <b>marla_Request</b>
<li>marla_Request* <b>marla_Request_new</b>(struct marla_Connection* cxn, struct marla_Server* server)
<li>void <b>marla_Request_destroy</b>(marla_Request*)
<li>void <b>marla_killRequest</b>(struct marla_Request* req, const char* reason, ...)
<li>int <b>marla_clientAccept</b>(marla_Connection* cxn)
<li>int <b>marla_clientRead</b>(marla_Connection* cxn)
<li>int <b>marla_clientWrite</b>(marla_Connection* cxn)
<li>int <b>marla_writeWebSocketHeader</b>(struct marla_Request* req, unsigned char opcode, uint64_t frameLen)
<li>int <b>marla_writeWebSocket</b>(struct marla_Request* req, unsigned char* data, int dataLen)
<li>int <b>marla_readWebSocket</b>(struct marla_Request* req, unsigned char* data, int dataLen)
<li>int <b>marla_WebSocketRemaining</b>(struct marla_Request* req)
<li>void <b>marla_putbackWebSocketRead</b>(struct marla_Request* req, int dataLen)
<li>const char* <b>marla_nameRequestReadStage</b>(enum marla_RequestReadStage stage)
<li>const char* <b>marla_nameRequestWriteStage</b>(enum marla_RequestWriteStage stage)
<li>const char* <b>marla_nameClientEvent</b>(enum marla_ClientEvent ev)
<li><b>MIN_METHOD_LENGTH</b>
<li><b>MAX_METHOD_LENGTH</b>
<li><b>MAX_FIELD_NAME_LENGTH</b>
<li><b>MAX_FIELD_VALUE_LENGTH</b>
<li><b>MAX_WEBSOCKET_NONCE_LENGTH</b>
<li><b>MAX_URI_LENGTH</b>
<li><b>marla_MAX_CHUNK_SIZE</b>
<li><b>marla_MAX_CHUNK_SIZE_LINE</b>
<li><b>MAX_WEBSOCKET_CONTROL_PAYLOAD</b>
<li><b>marla_MESSAGE_IS_CHUNKED</b>
<li><b>marla_MESSAGE_LENGTH_UNKNOWN</b>
<li><b>marla_MESSAGE_USES_CLOSE</b>
</ul>
<h3>Marla</h3>
Marla is a HTTP 1.1 server that requires <a href="https://apr.apache.org/">APR</a>, <a href="https://www.openssl.org/">OpenSSL</a>, and <a href="http://invisible-island.net/ncurses/">ncurses</a>. Marla is written to work on Linux 2.6.17 or greater. Marla is licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, version 2.0</a>.
<p>
<h3>Table of Contents</h3>
<ol>
<li><a href="main.html">Main</a>
<li><a href="server.html">Server</a>
<li><a href="connection.html">Connection</a>
<li><a href="request.html">Request</a>
<li><a href="ChunkedPageRequest.html">ChunkedPageRequest</a>
<li><a href="backend.html">Backend</a>
<li><a href="ring.html">Ring</a>
</ol>
</nav>
</body>
</html>
