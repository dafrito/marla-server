<!DOCTYPE html>
<html>
<head>
<style>
table
{
border-collapse: collapse;
}
table td, table th
{
border: 1px solid grey;
}
</style>
<title>Chunked transfer encoding - Rainback</title>
<link rel=stylesheet type=text/css href="style.css">
</head>
<body>
<main class=content>
<h1>Chunked transfer encoding - Rainback</h1>
<h2>struct marla_ChunkedPageRequest</h2>
<table>
<tr><td>void(*handler)(struct marla_ClientRequest*, struct marla_ChunkedPageRequest*)<td>Handler that is used to fill the resp internal input ring.
<tr><td>void* handleData<td>Space for opaque handler data.
<tr><td>int handleStage<td>The internal generation stage.
<tr><td>int index<td>The internal index of the generated input.
<tr><td>marla_Ring* resp<td>The internal buffer that will be written as chunks.
<tr><td>enum marla_ChunkResponseStage stage<td>The stage of chunk writing.
</table>
<p>
Set this to marla_CHUNK_RESPONSE_TRAILER in the handler when the output is complete.
<h2>enum marla_ChunkResponseStage</h2>
<table>
<tr><th>Constant<th>Value<th>Description
<tr><td>marla_CHUNK_RESPONSE_GENERATE<td>0<td>Invokes the handler to generate data.
<tr><td>marla_CHUNK_RESPONSE_HEADER<td>1<td>The header is to be written.
<tr><td>marla_CHUNK_RESPONSE_RESPOND<td>2<td>The data is being written.
<tr><td>marla_CHUNK_RESPONSE_TRAILER<td>3<td>No more data to be written. Set by the generator.
<tr><td>marla_CHUNK_RESPONSE_DONE<td>4<td>No more data or framing to be written.
</table>
<h2>const char* marla_nameChunkResponseStage(enum marla_ChunkResponseStage stage)</h2>
Returns a user-readable string representing the chunk response stage.
<h2>struct marla_ChunkedPageRequest* marla_ChunkedPageRequest_new(size_t inputBufSize, marla_ClientRequest* req)</h2>
Creates and returns a new marla_ChunkedPageRequest using the given input buffer size and client request.
<h2>int marla_writeChunk(struct marla_ChunkedPageRequest* cpr, marla_Ring* output)</h2>
Writes a chunk from the marla_ChunkedPageRequest's generated input ring to the given output ring.
<p>
Returns 0 and sets the stage to marla_CHUNK_RESPONSE_TRAILER if no more data is to be written.
<h2>void marla_measureChunk(size_t slotLen, int avail, size_t* prefix_len, size_t* availUsed)</h2>
Measures into the given prefix_len and availUsed, the size of a chunk that will best fit the
given slot.
<h2>void marla_ChunkedPageRequest_free(struct marla_ChunkedPageRequest* cpr)</h2>
Destroys the given marla_ChunkedPageRequest.
<h2>int marla_ChunkedPageRequest_process(struct marla_ChunkedPageRequest* cpr)</h2>
Writes the given marla_ChunkedPageRequest to the given marla_ClientRequest.
<h2>void marla_chunkedRequestHandler(struct marla_ClientRequest* req, enum marla_ClientEvent ev, void* data, int datalen)</h2>
A request handler, for use with a marla_ClientRequest.
</main>
<nav class=toc>
<h3>Chunked transfer encoding - Rainback</h3>
<ul>
<li>struct <b>marla_ChunkedPageRequest</b>
<li>const char* <b>marla_nameChunkResponseStage</b>(enum marla_ChunkResponseStage stage)
<li>struct marla_ChunkedPageRequest* <b>marla_ChunkedPageRequest_new</b>()
<li>int <b>marla_writeChunk</b>(struct marla_ChunkedPageRequest* cpr, marla_Ring* output)
<li>void <b>marla_measureChunk</b>(size_t slotLen, int avail, size_t* prefix_len, size_t* availUsed)
<li>void <b>marla_ChunkedPageRequest_free</b>(struct marla_ChunkedPageRequest* cpr)
<li>void <b>marla_ChunkedPageRequest_process</b>(struct marla_ChunkedPageRequest* cpr)
</ul>
</nav>
</body>
</html>
